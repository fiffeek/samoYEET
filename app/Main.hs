-- automatically generated by BNF Converter
module Main where


import           System.IO                      ( stdin
                                                , hGetContents
                                                )
import           System.Environment             ( getArgs
                                                , getProgName
                                                )
import           System.Exit                    ( exitFailure
                                                , exitSuccess
                                                )
import           Control.Monad                  ( when )

import           Samoyeet.Lex
import           Samoyeet.Par
import           Samoyeet.Skel
import           Samoyeet.Print
import           Samoyeet.Abs




import           Samoyeet.ErrM
import           Evaluate                       ( execInterpretMonad )
import           TypeChecker                    ( execTypeCheckerMonad )

import           Common.CommandLineHelpers
import           Data.Maybe
import           Common.Logging

type ParseFun = [Token] -> Err Program

runFile :: CommandLineArguments -> ParseFun -> FilePath -> IO ()
runFile cla p f = putStrLn f >> readFile f >>= run cla p

run :: CommandLineArguments -> ParseFun -> String -> IO ()
run cla p s = parse
  (\tree -> execTypeCheckerMonad tree $ execInterpretMonad tree)
 where
  parseError = "Parse Error: "
  ts         = myLexer s
  parse cont = case p ts of
    Bad s                  -> putStrLn $ parseError ++ s
    Ok  entire@(Program p) -> do
      showTree cla entire
      cont p


showTree :: CommandLineArguments -> Program -> IO ()
showTree v tree = do
  putStrV v $ "\n[Abstract Syntax]\n\n" ++ show tree
  putStrV v $ "\n[Linearized tree]\n\n" ++ printTree tree

usage :: CommandLineArguments -> IO ()
usage cla = do
  putStrLn $ explain cla
  exitFailure

main :: IO ()
main = do
  args <- getArgs
  let parsed = parseArgs args
  dispatch parsed
 where
  dispatch parsed
    | isJust . maybeHelp $ parsed = usage parsed
    | otherwise = mapM_ (runFile parsed pProgram) (getFiles parsed)





