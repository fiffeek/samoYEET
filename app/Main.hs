-- automatically generated by BNF Converter
module Main where


import           System.IO                      ( stdin
                                                , hGetContents
                                                )
import           System.Environment             ( getArgs
                                                , getProgName
                                                )
import           System.Exit                    ( exitFailure
                                                , exitSuccess
                                                )
import           Control.Monad                  ( when )

import           Samoyeet.Lex
import           Samoyeet.Par
import           Samoyeet.Skel
import           Samoyeet.Print
import           Samoyeet.Abs




import           Samoyeet.ErrM
import           Interpreter.Evaluate           ( execInterpretMonad )
import           TypeChecker.TypeCheckerRunner  ( execTypeCheckerMonad )

import           Data.Maybe
import           Common.Utils
import           Common.CommandLineHelpers
import           Common.Logging

type ParseFun = [Token] -> Err Program

runFile :: CommandLineArguments -> ParseFun -> FilePath -> IO ()
runFile cla p f = putStrLn f >> readFile f >>= run cla p

run :: CommandLineArguments -> ParseFun -> String -> IO ()
run cla p s = parse
  (\tree -> typeCheck tree $ execInterpretMonad tree)
 where
  typeCheck tree cont = if isTypeCheckEnabled cla then execTypeCheckerMonad tree $ cont else cont
  parseError = "Parse Error: "
  ts         = myLexer s
  parse cont = case p ts of
    Bad s                  -> putStrLn $ parseError ++ s
    Ok  entire@(Program p) -> do
      showTree cla entire
      cont p

usage :: CommandLineArguments -> IO ()
usage cla = do
  putStrLn $ explain cla
  exitFailure

main :: IO ()
main = do
  args <- getArgs
  let parsed = parseArgs args
  dispatch parsed
 where
  dispatch parsed
    | isJust . maybeHelp $ parsed = usage parsed
    | otherwise = mapM_ (runFile parsed pProgram) (getFiles parsed)





