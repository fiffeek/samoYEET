-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Samoyeet.Par where
import Samoyeet.Abs
import Samoyeet.Lex
import Samoyeet.ErrM

}

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%name pProgram Program
%token
  '!' { PT _ (TS _ 1) }
  '!=' { PT _ (TS _ 2) }
  '%' { PT _ (TS _ 3) }
  '&' { PT _ (TS _ 4) }
  '(' { PT _ (TS _ 5) }
  ')' { PT _ (TS _ 6) }
  '*' { PT _ (TS _ 7) }
  '+' { PT _ (TS _ 8) }
  '++' { PT _ (TS _ 9) }
  ',' { PT _ (TS _ 10) }
  '-' { PT _ (TS _ 11) }
  '--' { PT _ (TS _ 12) }
  '.' { PT _ (TS _ 13) }
  '.at(' { PT _ (TS _ 14) }
  '.length()' { PT _ (TS _ 15) }
  '/' { PT _ (TS _ 16) }
  ':' { PT _ (TS _ 17) }
  ';' { PT _ (TS _ 18) }
  '<' { PT _ (TS _ 19) }
  '<=' { PT _ (TS _ 20) }
  '=' { PT _ (TS _ 21) }
  '==' { PT _ (TS _ 22) }
  '>' { PT _ (TS _ 23) }
  '>=' { PT _ (TS _ 24) }
  'Fun' { PT _ (TS _ 25) }
  'List' { PT _ (TS _ 26) }
  '[]' { PT _ (TS _ 27) }
  'and' { PT _ (TS _ 28) }
  'boolean' { PT _ (TS _ 29) }
  'break;' { PT _ (TS _ 30) }
  'continue;' { PT _ (TS _ 31) }
  'do' { PT _ (TS _ 32) }
  'else' { PT _ (TS _ 33) }
  'false' { PT _ (TS _ 34) }
  'for' { PT _ (TS _ 35) }
  'from' { PT _ (TS _ 36) }
  'if' { PT _ (TS _ 37) }
  'int' { PT _ (TS _ 38) }
  'or' { PT _ (TS _ 39) }
  'push' { PT _ (TS _ 40) }
  'return' { PT _ (TS _ 41) }
  'string' { PT _ (TS _ 42) }
  'to' { PT _ (TS _ 43) }
  'true' { PT _ (TS _ 44) }
  'void' { PT _ (TS _ 45) }
  'while' { PT _ (TS _ 46) }
  'yeet' { PT _ (TS _ 47) }
  '{' { PT _ (TS _ 48) }
  '}' { PT _ (TS _ 49) }

  L_ident {PT _ (TV $$)}
  L_integ {PT _ (TI $$)}
  L_quoted {PT _ (TL $$)}

%%

Ident :: {
  Ident 
}
: L_ident {
  Ident $1 
}

Integer :: {
  Integer 
}
: L_integ {
  read $1 
}

String :: {
  String 
}
: L_quoted {
  $1 
}

Program :: {
  Program 
}
: ListStmt {
  Samoyeet.Abs.Program (reverse $1)
}

Arg :: {
  Arg 
}
: SType Ident {
  Samoyeet.Abs.Arg $1 $2 
}
| SType '&' Ident {
  Samoyeet.Abs.RefArg $1 $3 
}

ListArg :: {
  [Arg]
}
: {
  [] 
}
| Arg {
  (:[]) $1 
}
| Arg ',' ListArg {
  (:) $1 $3 
}

Block :: {
  Block 
}
: '{' ListStmt '}' {
  Samoyeet.Abs.Block (reverse $2)
}

ListStmt :: {
  [Stmt]
}
: {
  [] 
}
| ListStmt Stmt {
  flip (:) $1 $2 
}

Stmt :: {
  Stmt 
}
: ';' {
  Samoyeet.Abs.Empty 
}
| Block {
  Samoyeet.Abs.BStmt $1 
}
| SType ListItem ';' {
  Samoyeet.Abs.Decl $1 $2 
}
| Ident '=' Expr ';' {
  Samoyeet.Abs.Ass $1 $3 
}
| Ident '++' ';' {
  Samoyeet.Abs.Incr $1 
}
| Ident '--' ';' {
  Samoyeet.Abs.Decr $1 
}
| 'return' Expr ';' {
  Samoyeet.Abs.Ret $2 
}
| 'return' ';' {
  Samoyeet.Abs.VRet 
}
| 'if' '(' Expr ')' Stmt {
  Samoyeet.Abs.Cond $3 $5 
}
| 'if' '(' Expr ')' Stmt 'else' Stmt {
  Samoyeet.Abs.CondElse $3 $5 $7 
}
| 'while' '(' Expr ')' Stmt {
  Samoyeet.Abs.While $3 $5 
}
| 'break;' {
  Samoyeet.Abs.SBreak 
}
| 'continue;' {
  Samoyeet.Abs.SContinue 
}
| Expr ';' {
  Samoyeet.Abs.SExp $1 
}
| 'for' Ident 'from' Expr 'to' Expr 'do' Stmt {
  Samoyeet.Abs.For $2 $4 $6 $8 
}
| 'yeet' Expr ';' {
  Samoyeet.Abs.Print $2 
}
| SType Ident '(' ListArg ')' Block {
  Samoyeet.Abs.SFnDef $1 $2 $4 $6 
}
| Ident '.' 'push' '(' Expr ')' {
  Samoyeet.Abs.ListPush $1 $5 
}

Item :: {
  Item 
}
: Ident {
  Samoyeet.Abs.NoInit $1 
}
| Ident '=' Expr {
  Samoyeet.Abs.Init $1 $3 
}

ListItem :: {
  [Item]
}
: Item {
  (:[]) $1 
}
| Item ',' ListItem {
  (:) $1 $3 
}

SType :: {
  SType 
}
: 'int' {
  Samoyeet.Abs.Int 
}
| 'string' {
  Samoyeet.Abs.Str 
}
| 'boolean' {
  Samoyeet.Abs.Bool 
}
| 'void' {
  Samoyeet.Abs.Void 
}
| 'List' '<' SType '>' {
  Samoyeet.Abs.TList $3 
}
| 'Fun' '<' SType '(' ListMaybeRefType ')' '>' {
  Samoyeet.Abs.Fun $3 $5 
}

MaybeRefType :: {
  MaybeRefType 
}
: SType {
  Samoyeet.Abs.NoRef $1 
}
| SType '&' {
  Samoyeet.Abs.JustRef $1 
}

ListMaybeRefType :: {
  [MaybeRefType]
}
: {
  [] 
}
| MaybeRefType {
  (:[]) $1 
}
| MaybeRefType ',' ListMaybeRefType {
  (:) $1 $3 
}

ListSType :: {
  [SType]
}
: {
  [] 
}
| SType {
  (:[]) $1 
}
| SType ',' ListSType {
  (:) $1 $3 
}

Expr5 :: {
  Expr 
}
: Expr6 '.length()' {
  Samoyeet.Abs.ListLength $1 
}
| Expr6 '.at(' Expr6 ')' {
  Samoyeet.Abs.ListAt $1 $3 
}
| '-' Expr6 {
  Samoyeet.Abs.Neg $2 
}
| '!' Expr6 {
  Samoyeet.Abs.Not $2 
}
| Expr6 {
  $1 
}

Expr6 :: {
  Expr 
}
: Ident {
  Samoyeet.Abs.EVar $1 
}
| Integer {
  Samoyeet.Abs.ELitInt $1 
}
| 'true' {
  Samoyeet.Abs.ELitTrue 
}
| 'false' {
  Samoyeet.Abs.ELitFalse 
}
| Ident '(' ListExpr ')' {
  Samoyeet.Abs.EApp $1 $3 
}
| String {
  Samoyeet.Abs.EString $1 
}
| '(' Expr ')' {
  $2 
}

Expr4 :: {
  Expr 
}
: Expr4 MulOp Expr5 {
  Samoyeet.Abs.EMul $1 $2 $3 
}
| Expr5 {
  $1 
}

Expr3 :: {
  Expr 
}
: Expr3 AddOp Expr4 {
  Samoyeet.Abs.EAdd $1 $2 $3 
}
| Expr4 {
  $1 
}

Expr2 :: {
  Expr 
}
: Expr2 RelOp Expr3 {
  Samoyeet.Abs.ERel $1 $2 $3 
}
| Expr3 {
  $1 
}

Expr1 :: {
  Expr 
}
: Expr2 'and' Expr1 {
  Samoyeet.Abs.EAnd $1 $3 
}
| Expr2 {
  $1 
}

Expr :: {
  Expr 
}
: Expr1 'or' Expr {
  Samoyeet.Abs.EOr $1 $3 
}
| '[]' '(' ListArg ')' ':' SType Block {
  Samoyeet.Abs.ELambda $3 $6 $7 
}
| Expr1 {
  $1 
}

ListExpr :: {
  [Expr]
}
: {
  [] 
}
| Expr {
  (:[]) $1 
}
| Expr ',' ListExpr {
  (:) $1 $3 
}

AddOp :: {
  AddOp 
}
: '+' {
  Samoyeet.Abs.Plus 
}
| '-' {
  Samoyeet.Abs.Minus 
}

MulOp :: {
  MulOp 
}
: '*' {
  Samoyeet.Abs.Times 
}
| '/' {
  Samoyeet.Abs.Div 
}
| '%' {
  Samoyeet.Abs.Mod 
}

RelOp :: {
  RelOp 
}
: '<' {
  Samoyeet.Abs.LTH 
}
| '<=' {
  Samoyeet.Abs.LE 
}
| '>' {
  Samoyeet.Abs.GTH 
}
| '>=' {
  Samoyeet.Abs.GE 
}
| '==' {
  Samoyeet.Abs.EQU 
}
| '!=' {
  Samoyeet.Abs.NE 
}

{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens


}

